import pathlib
import numpy as np
import tqdm
import shapely.geometry
import rasterio

import passion.util

def generate_osm(input_path: pathlib.Path,
                 output_path: pathlib.Path,
                 osm_request_interval: float = 5,
                 num_retries: int = 5
):
  '''Segments a full dataset generated by generate_dataset(),
  saving the open OSM footprints as segmented masks
  in the specified folder.

  Input images must have the naming format specified by gis.get_filename().

  Segmented images are saved with the same name as the original
  images appending '_MASK' in the end.

  ---
  
  input_path            -- Path, folder in which image_retrieval dataset was generated.
  output_path           -- Path, folder in which masks and filtered images will be stored.
  osm_request_interval  -- float, seconds to wait per request retry.
  num_retries           -- int, number of times to retry a request after an error.
  '''
  output_path.mkdir(parents=True, exist_ok=True)

  paths = list(input_path.glob('*.tif'))
  pbar = tqdm.tqdm(paths)
  for img_path in pbar:
    src = rasterio.open(img_path)
    r = src.read(1)
    g = src.read(2)
    b = src.read(3)
    image = np.dstack((b,g,r))

    zoom = int(src.tags().get('zoom_level'))
    img_center_x, img_center_y = src.xy(src.height // 2, src.width // 2)
    img_center_lat, img_center_lon = passion.util.gis.xy_tolatlon(img_center_x, img_center_y, zoom)

    latlon, zoom = passion.util.gis.extract_filename(img_path.stem)

    seg_image = segment_img(image, (img_center_lat, img_center_lon), zoom, osm_request_interval, num_retries)

    seg_image = postprocess_output(seg_image)

    seg_image = seg_image[np.newaxis, ...]
    channels, height, width = seg_image.shape
    new_dataset = rasterio.open(str(output_path / (img_path.stem + '_MASK.tif')), 'w', driver='GTiff',
                                        height = height, width = width,
                                        count=1, dtype=str(seg_image.dtype),
                                        crs=src.crs,
                                        transform=src.transform)
    new_dataset.update_tags(**src.tags())
    new_dataset.write(seg_image)
    new_dataset.close()

  return

def segment_img(image: np.ndarray, latlon: tuple, zoom: int, osm_request_interval: float = 5, num_retries: int = 5):
  ''''Segments a single image in numpy format with
  the open OSM footprints. 
  
  Returns a binary numpy image.'''

  print('Segmenting image...')

  if type(image) != np.ndarray:
    print('Image type: {0} not a np.array'.format(type(image)))
    return None
  if len(image.shape) != 3 or image.shape[-1] != 3:
    print('Image shape: {0} not in format MxNx3'.format(image.shape))
    return None

  bbox = passion.util.gis.get_image_bbox(latlon, zoom, image.shape)

  img_buildings = passion.util.osm.get_footprints_latlon(bbox, osm_request_interval, num_retries)

  img_buildings_xy_abs = [ [ (passion.util.gis.latlon_toXY(coord[0], coord[1], zoom)) for coord in building ] for building in img_buildings ]

  offset_x, offset_y = passion.util.gis.get_image_offset(bbox, zoom)

  img_buildings_xy = [ [ (coord[0]-offset_x, coord[1]-offset_y) for coord in building] for building in img_buildings_xy_abs]

  img_buildings_polygons = [ shapely.geometry.Polygon(building) for building in img_buildings_xy]

  seg_image = passion.util.shapes.outlines_to_image(img_buildings_xy, len(img_buildings_xy)*[1], image.shape[:2])

  return seg_image

def postprocess_output(image: np.ndarray):
  '''Transformations that are made to the output of the retrieved OSM footprints.
  
  No transformations are made by default, this method has to be overwritten.

  Returns a numpy image.
  '''
  return image